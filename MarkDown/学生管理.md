# 学生管理系统

### 概要设计
#### 1. 前端
```
	root-[1]学校1-[11]学院1-[111]专业1-[1111]班级1     
	   |    |-[12]学院2-[121]专业1-[1211]班级1
	   |	                  |-[1212]班级2
	   |-[2]学校2-[21]学院1 


	班级学生表
	|名字\t|学号\t|成绩\t|
	|xxx\t|111101\t|99\t|
	|xxx\t|111101\t|99\t|

	班级统计
	班级人数:23\t
	平均分：22\t 总分：9889\t
```
#### 2. 数据结构  
##### 树   
```
遍历树(Tree)
增加节点(Tree,Node)
删除节点(Tree,Node)

```
##### 树的节点(可能是学生)  
```c
	Struct Node
   {
		//指向父节点的指针
		char code[6];//代码（同时也是学生的id)
		char name[100]//名称;
		int score；(只有学生有分数)
		//指向子节点的指针（学生节点没有子节点）
   }
```
##### 堆栈

#### 3. 模块功能   
   * ##### 树层级 
	root-学校1-学院1-专业1-班级1-学生1     
   	编码 1-1-1-1-01
	所以学生1的编码是111101
	学校1的编码是100000    
   * ##### 查询 关键字(fd)
   	输入编码或者名称 输出当前树的所有子树    
   	学生需要详细信息 单独制表
 
   * ##### 增加 修改 删除 关键字(ad cg de)
			通过接收关键字以及后面的编码 来实现   

  * ##### 输出(包含统计)    
		 按照给定格式输出父节点
		学生单独制表        
		并统计班级中学生的成绩总分 平均分等
  * ##### 持久化层（数据库）
		将操作后的树以一定格式记录到文件

 4. 函数设计
	1. #### 工具类
		##### 初始化
		* void Init(Tree *a,Stack a)
		##### 复制节点数据
		* void Copyatob(Node *a,Node *b)   
		复制a中信息到b;		 
		##### 接收用户输入
		* void Catch(char S[100])      
		抓取用户输入的中的关键字和待操作的编码对象
		```
		将S分为关键字（head）和code(body)两段      
		
		char tmp[2];
		char tmpcode[6];
		if(tmp！=rv){	取6位code	 }//因为撤销不需要code避免读入空字符串
		if(tmp==ad)
		{
			Node tmp;
			//scanf 让用户输入信息并录入到tmp中;
			if(//通过code判断是普通节点还是学生){


			}

			Ad(Tree *a,Node *tmp);
		}
		else.....
		//格式错误特判重输入
		```
		##### 持久化(录入文件)
		* void Export(Tree *a)
		##### 读取文件
		* void Inport(Tree *a)
		
	2. 业务函数
		##### 增加 
		* void Ad(Tree *a,Node tmp)
		```
		通过新节点的Code      
		读取新节点的父节点和子节点
		并修改这两个节点的指针
		
		```
		##### 删除
		* void De(Tree *a,char code[6])
		```
		tmp=Fd(*a,code,1);
		根据code删除对应的节点
		``` 
		##### 查 
		* Node Fd(Tree *a,char a[100],int Mode)
		```
		//Mode 0精确 Mode 1模糊

		Node Ran;
		if(!mode)
		{
			char tmpcode[6];
			//只要a[100]前面的六个code字符
			遍历树(Tree*a){
				if(Node.code==tmpcode[6]){
				Copyatob(Node,R)
				return R;
				
				}
			}
		}
		else//模糊 将所有的节点接成链表？
		{
			遍历树(){
				if(Node.name==a[100]//NODE可能是学院也可能是学生){
					找到一个合法的,把R作为头节点（头节点也存数据）
					接到R的后面当作链表 最后返回R
					//模糊只用于输出 因此可以在这里直接打印
					而不需要调用PrintAll
				}
			}
		}
		``` 
		##### 修改
		* void Cg(Tree *a,char code[6])
		```
		temp=Fd(Tree *a,char code[],1);
		然后修改temp
		``` 
		##### 输出（+统计）
		* PrintAll(Tree *a,int Mode,char code[6])
	```
	{	
		//Mode 0 输出整棵树 并将所有学生制表 以及班级的统计数据
		//Mode 1 不涉及班级的输出
		只需要输出到code代表的节点以及它的子节点
		//Mode 2 输入的code是班级
		输出到该班级 只将该班级的学生单独制表 以及统计数据
		//Mode 3 输入的Code是学生
		输出到该班级
		将该学生的数据制表（不要输出其他学生 其他班级的数据）

		格式依照上述需求
	}
	```

#### 5.  Ex
   ##### 撤销 （关键字 rv）
  * void Revoke(Stack *s,Tree *a) 
假如要操作班级非常麻烦！
```
预想
修改时将原来的节点Node压入栈中
新建一个节点=原节点并进行相应修改
将父节点的指针指向新节点 
将子节点的指针指向新节点

当遇到撤销命令时
取出栈顶节点 
读取它的父节点和子节点
修改父节点和子节点的指针
```